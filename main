/***********************************************************************/
/*                                                                     */
/*  FILE        :ledcube.c                                             */
/*  DATE        :Wed, Mar 20, 2019                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8/3694F                                              */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/
//2パターン                  
#include "iodefine.h"


#define delay_loop 10		//１コマ当たりの表示時間を設定（レイヤーの表示時間*4*１コマ当たりのループ数＝１コマの時間）
#define delay_layer 3000	//レイヤーあたりの表示時間を設定
#define RIGHT IO.PDRB.BIT.B6
#define LEFT IO.PDRB.BIT.B4
#define FORWARD IO.PDRB.BIT.B5
#define REVERSE IO.PDRB.BIT.B7
#define DOWN IO.PDRB.BIT.B3
#define UP IO.PDRB.BIT.B2

void main(void);

void pat_output(int layer, int layernr);
void output(int layer1, int layer2, int layer3, int layer4);
int loop(int num);
void delay_t(long int t);

void main(void)
{
	unsigned int layer_s = 0x0033;
	unsigned int layer_h = 0x03;
	
	int pattern[28] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 1, 1, 0, 0, 3, 3, 2, 2, 4, 0, 0, 1, 1, 2, 2, 3, 3, 5, 5};
	int pattern2[20][4] = {{0x0001, 0x0000, 0x0000, 0x0000},
						{0x0013, 0x0001, 0x0000, 0x0000},
						{0x0137, 0x0013, 0x0001, 0x0000},
						{0x137F, 0x0137, 0x0013, 0x0001},
						{0x37FF, 0x137F, 0x0137, 0x0013},
						{0x7FFF, 0x37FF, 0x137F, 0x0137},
						{0xFFFF, 0x7FFF, 0x37FF, 0x137F},
						{0xFFFF, 0xFFFF, 0x7FFF, 0x37FF},
						{0xFFFF, 0xFFFF, 0xFFFF, 0x7FFF},
						{0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
						{0xFFFE, 0xFFFF, 0xFFFF, 0xFFFF},
						{0xFFEC, 0xFFFE, 0xFFFF, 0xFFFF},
						{0xFEC8, 0xFFEC, 0xFFFE, 0xFFFF},
						{0xEC80, 0xFEC8, 0xFFEC, 0xFFFE},
						{0xC800, 0xEC80, 0xFEC8, 0xFFEC},
						{0x8000, 0xC800, 0xEC80, 0xFEC8},
						{0x0000, 0x8000, 0xC800, 0xEC80},
						{0x0000, 0x0000, 0x8000, 0xC800},
						{0x0000, 0x0000, 0x0000, 0x8000},
						{0x0000, 0x0000, 0x0000, 0x0000}};
	int pattern3[15][4] = {{0xFFFF, 0x0000, 0x0000, 0x0000},
						{0x0000, 0xFFFF, 0x0000, 0x0000},
						{0x0000, 0x0000, 0xFFFF, 0x0000},
						{0x0000, 0x0000, 0x0000, 0xFFFF},
						{0x0000, 0x0000, 0x0000, 0x0000},
						{0x8888, 0x8888, 0x8888, 0x8888},
						{0x4444, 0x4444, 0x4444, 0x4444},
						{0x2222, 0x2222, 0x2222, 0x2222},
						{0x1111, 0x1111, 0x1111, 0x1111},
						{0x0000, 0x0000, 0x0000, 0x0000},
						{0xF000, 0xF000, 0xF000, 0xF000},
						{0x0F00, 0x0F00, 0x0F00, 0x0F00},
						{0x00F0, 0x00F0, 0x00F0, 0x00F0},
						{0x000F, 0x000F, 0x000F, 0x000F},
						{0x0000, 0x0000, 0x0000, 0x0000}};

	
	int i = 0;
	long j = 0;
	int mode = 0;
	int k = 0;
	
	IO.PCR1 = 0xf0;
	IO.PCR5 = 0xff;
	IO.PCR8 = 0xff;
		
	while(1)
	{
		switch(mode)
		{
			case 0://機能選択
				if(UP == 0)
				{
					while(UP == 0);
					mode = 1;
				}	
				if(DOWN == 0)
				{
					while(DOWN == 0);
					mode = 2;
				}
				if(RIGHT == 0)
				{
					while(RIGHT == 0);
					mode = 3;
				}
				if(LEFT == 0)
				{
					while(LEFT == 0);
					mode = 4;
				}
				break;
			case 1://自動
				while(1)
				{
	
					pat_output(layer_s, layer_h);
					j++;
					while(j > 10)
					{
						if(pattern[i] == 2)
						{
							if((layer_s != 0x3300) && (layer_s != 0x0330) && (layer_s != 0x0033))//右端じゃないとき
							{
								layer_s = layer_s >> 1;//右に移動
							}
						}
						if(pattern[i] == 0)
						{
							if((layer_s != 0xcc00) && (layer_s != 0x0cc0) && (layer_s != 0x00cc))//左端じゃないとき
							{
								layer_s = layer_s << 1;//左に移動
							}
						}
						if(pattern[i] == 1)
						{
							if(layer_s < 0x3300)//奥端じゃないとき
							{
								layer_s = layer_s << 4;//奥に移動
							}
						}
						if(pattern[i] == 3)
						{
							if(layer_s > 0x00cc)//前端じゃないとき
							{
								layer_s = layer_s >> 4;//前に移動
							}
						}
						if(pattern[i] == 5)
						{
							if(layer_h > 0x03)//下端じゃないとき
							{
								layer_h = layer_h >> 1;//下に移動
							}
						}
						if(pattern[i] == 4)
						{
							if(layer_h < 0x0c)//上端じゃないとき
							{
								layer_h = layer_h << 1;//上に移動
							}
						}
						
						i++;
						j = 0;
						if(i > 27)
						{
							i = 0;
						}
					}
				}
				break;
				
			case 2://手動
				while(1)
				{
		

					pat_output(layer_s, layer_h);
					
					if(RIGHT == 0)
					{
						while(RIGHT == 0);
						if((layer_s != 0x3300) && (layer_s != 0x0330) && (layer_s != 0x0033))
						{
							layer_s = layer_s >> 1;
						}
					}
					if(LEFT == 0)
					{
						while(IO.PDRB.BIT.B4 == 0);
						if((layer_s != 0xcc00) && (layer_s != 0x0cc0) && (layer_s != 0x00cc))
						{
							layer_s = layer_s << 1;
						}
					}
					if(FORWARD == 0)
					{
						while(FORWARD == 0);
						if(layer_s < 0x3300)
						{
							layer_s = layer_s << 4;
						}
					}
					if(REVERSE == 0)
					{
						while(REVERSE == 0);
						if(layer_s > 0x00cc)
						{
							layer_s = layer_s >> 4;
						}
					}
					if(DOWN == 0)
					{
						while(DOWN == 0);
						if(layer_h > 0x03)
						{
							layer_h = layer_h >> 1;
						}
					}
					if(UP == 0)
					{
						while(UP == 0);
						if(layer_h < 0x0c)
						{
							layer_h = layer_h << 1;
						}
					}
					
				}
				break;

			case 3://アニメーション1
				while(1)
				{
					output(pattern2[k][0], pattern2[k][1], pattern2[k][2], pattern2[k][3]);
					k = loop(19);
				}
				break;
				
			case 4://アニメーション2
				while(1)
				{
					output(pattern3[k][0], pattern3[k][1], pattern3[k][2], pattern3[k][3]);
					k = loop(14);
				}
				break;
		}
	}
}

//特定のパターンを任意に操作できる関数

void pat_output(int layer, int layernr)
{
	IO.PDR1.BYTE = 0xe0;//1段目
	if((layernr & 0x01) == 0x01)
	{
			IO.PDR5.BYTE = (layer >> 8) & 0x00ff;
			IO.PDR8.BYTE = layer & 0x00ff;
	}
	else
	{
			IO.PDR5.BYTE = 0x00;
			IO.PDR8.BYTE = 0x00;
	}
	delay_t(delay_layer);

	IO.PDR1.BYTE = 0xd0;//2段目		
	if((layernr & 0x02) == 0x02)
	{
			IO.PDR5.BYTE = (layer >> 8) & 0x00ff;
			IO.PDR8.BYTE = layer & 0x00ff;
	}
	else
	{
			IO.PDR5.BYTE = 0x00;
			IO.PDR8.BYTE = 0x00;
	}
	delay_t(delay_layer);

	IO.PDR1.BYTE = 0xb0;//3段目		
	if((layernr & 0x04) == 0x04)
	{
			IO.PDR5.BYTE = (layer >> 8) & 0x00ff;
			IO.PDR8.BYTE = layer & 0x00ff;
	}
	else
	{
			IO.PDR5.BYTE = 0x00;
			IO.PDR8.BYTE = 0x00;
	}
	delay_t(delay_layer);

	IO.PDR1.BYTE = 0x70;//4段目		
	if((layernr & 0x08) == 0x08)
	{
			IO.PDR5.BYTE = (layer >> 8) & 0x00ff;
			IO.PDR8.BYTE = layer & 0x00ff;
	}
	else
	{
			IO.PDR5.BYTE = 0x00;
			IO.PDR8.BYTE = 0x00;
	}
	delay_t(delay_layer);
}

//あらかじめ設定したパターンを表示する関数

void output(int layer1, int layer2, int layer3, int layer4)
{
	IO.PDR1.BYTE = 0xe0;//1段目
	IO.PDR5.BYTE = (layer1 >> 8) & 0x00ff;
	IO.PDR8.BYTE = layer1 & 0x00ff;
	delay_t(delay_layer);

	IO.PDR1.BYTE = 0xd0;//2段目		
	IO.PDR5.BYTE = (layer2 >> 8) & 0x00ff;
	IO.PDR8.BYTE = layer2 & 0x00ff;

	delay_t(delay_layer);

	IO.PDR1.BYTE = 0xb0;//3段目		
	IO.PDR5.BYTE = (layer3 >> 8) & 0x00ff;
	IO.PDR8.BYTE = layer3 & 0x00ff;

	delay_t(delay_layer);

	IO.PDR1.BYTE = 0x70;//4段目		
	IO.PDR5.BYTE = (layer4 >> 8) & 0x00ff;
	IO.PDR8.BYTE = layer4 & 0x00ff;

	delay_t(delay_layer);
}

int n = 0;
int m = 0;

//1コマを表示する時間を設定する関数

int loop(int num)
{
	m++;
	if(m > delay_loop)
	{
		n++;
		m = 0;
		if(n > num)
		{
			n = 0;
		}
	}
	return n;
}

void delay_t(long int t)
{
	while(t--);
}
